import telebot
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from PIL import Image, ImageDraw, ImageOps, ImageFont
import requests
from io import BytesIO
import mysql.connector
import os

# Configura√ß√£o do bot e do banco de dados
API_TOKEN = 'YOUR_API_TOKEN'
bot = telebot.TeleBot(API_TOKEN)

db_config = {
    'user': 'seu_usuario',
    'password': 'sua_senha',
    'host': 'localhost',
    'database': 'seu_banco_de_dados'
}

ALBUM_PATH = 'album.png'
BACKGROUND_URL = 'https://i.pinimg.com/564x/19/a5/b0/19a5b0b149cd1a26f3fa7766061e902c.jpg'
BORDER_COLOR = '#DE3163'
CACHE_DIR = 'sticker_cache'

# Verifique se o diret√≥rio de cache existe
if not os.path.exists(CACHE_DIR):
    os.makedirs(CACHE_DIR)

def get_cached_sticker(sticker_url, hole_width, hole_height):
    """Retorna a imagem da figurinha redimensionada do cache ou faz o download e redimensiona se n√£o estiver no cache."""
    # Gere um nome de arquivo a partir da URL da figurinha
    sticker_filename = os.path.join(CACHE_DIR, os.path.basename(sticker_url))

    if not os.path.exists(sticker_filename):
        response = requests.get(sticker_url)
        sticker_image = Image.open(BytesIO(response.content))
        sticker_image = sticker_image.resize((hole_width, hole_height))

        # Adicionar borda √† figurinha
        bordered_sticker = ImageOps.expand(sticker_image, border=2, fill=BORDER_COLOR)
        bordered_sticker.save(sticker_filename)
    else:
        bordered_sticker = Image.open(sticker_filename)

    return bordered_sticker

def create_album(user_id, page):
    try:
        # Conecte-se ao banco de dados
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()

        # Baixar a imagem de fundo
        response = requests.get(BACKGROUND_URL)
        background = Image.open(BytesIO(response.content))

        # Dimens√µes da imagem 9:16 (por exemplo, 540x960 pixels)
        width, height = 540, 960
        background = background.resize((width, height))

        # Crie uma nova imagem com o fundo
        img = Image.new('RGB', (width, height))
        img.paste(background, (0, 0))

        draw = ImageDraw.Draw(img)

        # Dimens√µes dos buracos pretos
        hole_width, hole_height = 140, 210
        horizontal_padding = 20
        vertical_padding = 40  # Aumentando o espa√ßamento vertical

        # Calcula a posi√ß√£o inicial para centralizar a grade
        total_width = 3 * hole_width + 2 * horizontal_padding
        total_height = 3 * hole_height + 2 * vertical_padding
        start_x = (width - total_width) // 2
        start_y = (height - total_height) // 2

        # Coordenadas dos buracos (3x3)
        coordinates = []
        for row in range(3):
            for col in range(3):
                x0 = start_x + col * (hole_width + horizontal_padding)
                y0 = start_y + row * (hole_height + vertical_padding)
                x1 = x0 + hole_width
                y1 = y0 + hole_height
                coordinates.append((x0, y0, x1, y1))

        # Verifique quais figurinhas o usu√°rio possui na p√°gina atual
        cursor.execute('''
            SELECT stickers.id, stickers.image_path 
            FROM user_stickers 
            JOIN stickers ON user_stickers.sticker_id = stickers.id 
            WHERE user_stickers.user_id = %s AND stickers.page = %s
        ''', (user_id, page))
        stickers = cursor.fetchall()

        # Dicion√°rio de figurinhas do usu√°rio
        user_stickers = {sticker[0]: sticker[1] for sticker in stickers}

        # Preencha os buracos com as figurinhas
        for idx, coord in enumerate(coordinates):
            sticker_id = (page - 1) * 9 + idx + 1
            if sticker_id in user_stickers:
                # Carregar a figurinha correspondente do cache ou baixar se n√£o estiver no cache
                bordered_sticker = get_cached_sticker(user_stickers[sticker_id], hole_width, hole_height)
                
                # Colar a figurinha com borda na posi√ß√£o correta
                img.paste(bordered_sticker, (coord[0], coord[1]))
            else:
                # Preencher com buraco preto se a figurinha n√£o existir
                draw.rectangle(coord, fill='black')

        # Adicionar texto "P√°gina x/5" no rodap√©
        font = ImageFont.load_default()
        text = f"P√°gina {page}/5"
        text_bbox = draw.textbbox((0, 0), text, font=font)
        text_width = text_bbox[2] - text_bbox[0]
        text_x = (width - text_width) // 2
        text_y = height - 30  # 30 pixels acima do rodap√©
        draw.text((text_x, text_y), text, fill="black", font=font)

        # Salve a imagem
        img.save(ALBUM_PATH)
        cursor.close()
        conn.close()
        return True
    except Exception as e:
        print(f"Erro ao criar o √°lbum: {e}")
        return False

def get_navigation_markup():
    markup = InlineKeyboardMarkup()
    for i in range(1, 6):
        markup.add(InlineKeyboardButton(str(i), callback_data=f'page_{i}'))
    return markup

@bot.message_handler(commands=['start'])
def send_welcome(message):
    bot.reply_to(message, "Bem-vindo ao √°lbum de figurinhas do Dia dos Namorados!")

@bot.message_handler(commands=['album'])
def send_album(message):
    user_id = message.from_user.id
    page = 1  # P√°gina inicial
    bot.send_message(message.chat.id, "Gerando √°lbum, por favor aguarde...")
    if create_album(user_id, page):
        with open(ALBUM_PATH, 'rb') as photo:
            bot.send_photo(message.chat.id, photo, reply_markup=get_navigation_markup())
        bot.send_message(message.chat.id, "√Ålbum gerado com sucesso!")
    else:
        bot.send_message(message.chat.id, "Houve um erro ao gerar o √°lbum. Tente novamente mais tarde.")

@bot.callback_query_handler(func=lambda call: call.data.startswith('page_'))
def callback_page(call):
    user_id = call.from_user.id
    page = int(call.data.split('_')[1])
    bot.send_message(call.message.chat.id, f"Gerando √°lbum da p√°gina {page}, por favor aguarde...")
    if create_album(user_id, page):
        with open(ALBUM_PATH, 'rb') as photo:
            bot.edit_message_media(media=telebot.types.InputMediaPhoto(photo), chat_id=call.message.chat.id, message_id=call.message.message_id, reply_markup=get_navigation_markup())
        bot.send_message(call.message.chat.id, "√Ålbum atualizado com sucesso!")
    else:
        bot.send_message(call.message.chat.id, "Houve um erro ao atualizar o √°lbum. Tente novamente mais tarde.")

@bot.message_handler(commands=['send_sticker'])
def send_sticker(message):
    try:
        args = message.text.split()
        if len(args) != 3:
            bot.reply_to(message, "Uso: /send_sticker <user_id> <sticker_id>")
            return

        recipient_id = int(args[1])
        sticker_id = int(args[2])

        # Conecte-se ao banco de dados
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()

        # Verifique se a figurinha existe
        cursor.execute('SELECT id FROM stickers WHERE id = %s', (sticker_id,))
        if not cursor.fetchone():
            bot.reply_to(message, "Figurinha n√£o encontrada.")
            cursor.close()
            conn.close()
            return

        # Adicione a figurinha ao usu√°rio destinat√°rio
        cursor.execute('INSERT INTO user_stickers (user_id, sticker_id) VALUES (%s, %s)', (recipient_id, sticker_id))
        conn.commit()

        cursor.close()
        conn.close()

        bot.reply_to(message, f"Figurinha {sticker_id} enviada para o usu√°rio {recipient_id} com sucesso!")
    except Exception as e:
        bot.reply_to(message, f"Houve um erro ao enviar a figurinha: {e}")

# Inicie o bot

@bot.message_handler(commands=['send_sticker'])
def send_sticker(message):
    try:
        args = message.text.split()
        if len(args) != 3:
            bot.reply_to(message, "Uso: /send_sticker <user_id> <sticker_id>")
            return

        recipient_id = int(args[1])
        sticker_id = int(args[2])

        # Conecte-se ao banco de dados
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()

        # Verifique se a figurinha existe
        cursor.execute('SELECT id FROM stickers WHERE id = %s', (sticker_id,))
        if not cursor.fetchone():
            bot.reply_to(message, "Figurinha n√£o encontrada.")
            cursor.close()
            conn.close()
            return

        # Adicione a figurinha ao usu√°rio destinat√°rio
        cursor.execute('INSERT INTO user_stickers (user_id, sticker_id) VALUES (%s, %s)', (recipient_id, sticker_id))
        conn.commit()

        cursor.close()
        conn.close()

        bot.reply_to(message, f"Figurinha {sticker_id} enviada para o usu√°rio {recipient_id} com sucesso!")
    except Exception as e:
        bot.reply_to(message, f"Houve um erro ao enviar a figurinha: {e}")

@bot.message_handler(commands=['figurinhas'])
def send_random_stickers(message):
    try:
        user_id = message.from_user.id

        # Conecte-se ao banco de dados
        conn = mysql.connector.connect(**db_config)
        cursor = conn.cursor()

        # Selecionar 5 figurinhas aleat√≥rias, permitindo repetidas
        cursor.execute('SELECT id, image_path FROM stickers')
        all_stickers = cursor.fetchall()
        random_stickers = [random.choice(all_stickers) for _ in range(5)]

        # Verificar quais figurinhas o usu√°rio j√° possui
        cursor.execute('SELECT sticker_id FROM inventariofig WHERE user_id = %s', (user_id,))
        user_stickers = {row[0] for row in cursor.fetchall()}

        # Adicionar as figurinhas ao invent√°rio do usu√°rio e determinar bordas
        sticker_borders = []
        for sticker_id, sticker_url in random_stickers:
            if sticker_id in user_stickers:
                # Figurinha repetida
                border_color = 'black'
                border_width = 2
                cursor.execute('UPDATE inventariofig SET quantity = quantity + 1 WHERE user_id = %s AND sticker_id = %s', (user_id, sticker_id))
            else:
                # Figurinha nova
                border_color = 'gold'
                border_width = 5
                cursor.execute('INSERT INTO inventariofig (user_id, sticker_id, quantity) VALUES (%s, %s, 1)', (user_id, sticker_id))
            sticker_borders.append((sticker_url, border_color, border_width))
        
        conn.commit()
        cursor.close()
        conn.close()

        # Baixar a imagem de fundo
        background_url = 'https://telegra.ph/file/33879a99c60ca9d11e60c.png'
        response = requests.get(background_url)
        background = Image.open(BytesIO(response.content))

        # Definir tamanho e layout da imagem final (quadrada)
        width, height = background.size
        sticker_width, sticker_height = 140, 210  # Tamanho das figurinhas
        padding = 20  # Espa√ßo entre figurinhas

        # Redimensionar fundo para um quadrado se necess√°rio
        background = background.resize((width, width))

        # Criar uma nova imagem com o fundo
        img = Image.new('RGB', (width, width))
        img.paste(background, (0, 0))

        draw = ImageDraw.Draw(img)

        # Coordenadas das 5 figurinhas (3-2 centralizado)
        start_x = (width - 3 * sticker_width - 2 * padding) // 2
        start_y = (width - 2 * sticker_height - padding) // 2

        coordinates = [
            (start_x, start_y),
            (start_x + sticker_width + padding, start_y),
            (start_x + 2 * (sticker_width + padding), start_y),
            (start_x + (sticker_width // 2) + (padding // 2), start_y + sticker_height + padding),
            (start_x + sticker_width + (padding // 2) + (sticker_width // 2) + padding, start_y + sticker_height + padding)
        ]

        # Adicionar as figurinhas √† imagem
        for (sticker_url, border_color, border_width), coord in zip(sticker_borders, coordinates):
            response = requests.get(sticker_url)
            sticker_image = Image.open(BytesIO(response.content))
            sticker_image = sticker_image.resize((sticker_width, sticker_height))
            
            # Adicionar borda √† figurinha
            bordered_sticker = ImageOps.expand(sticker_image, border=border_width, fill=border_color)
            
            # Colar a figurinha na posi√ß√£o correta
            img.paste(bordered_sticker, coord)

        # Salvar a imagem final
        result_image_path = 'random_stickers.png'
        img.save(result_image_path)

        # Enviar a imagem das figurinhas sorteadas
        with open(result_image_path, 'rb') as photo:
            bot.send_photo(message.chat.id, photo)

        bot.reply_to(message, "5 figurinhas aleat√≥rias foram adicionadas ao seu invent√°rio!")
    except Exception as e:
        bot.reply_to(message, f"Houve um erro ao adicionar as figurinhas: {e}")

def get_cached_sticker(sticker_url, hole_width, hole_height):
    """Retorna a imagem da figurinha redimensionada do cache ou faz o download e redimensiona se n√£o estiver no cache."""
    response = requests.get(sticker_url)
    sticker_image = Image.open(BytesIO(response.content))
    sticker_image = sticker_image.resize((hole_width, hole_height))
    bordered_sticker = ImageOps.expand(sticker_image, border=2, fill='black')  # Borda padr√£o preta
    return bordered_sticker

def create_album(user_id, page):
    try:
        # Conecte-se ao banco de dados
        conn, cursor = conectar_banco_dados()

        # Baixar a imagem de fundo
        response = requests.get(BACKGROUND_URL)
        background = Image.open(BytesIO(response.content))

        # Dimens√µes da imagem 9:16 (por exemplo, 540x960 pixels)
        width, height = 540, 960
        background = background.resize((width, height))

        # Crie uma nova imagem com o fundo
        img = Image.new('RGB', (width, height))
        img.paste(background, (0, 0))

        draw = ImageDraw.Draw(img)

        # Dimens√µes dos buracos pretos
        hole_width, hole_height = 140, 210
        horizontal_padding = 20
        vertical_padding = 40  # Aumentando o espa√ßamento vertical

        # Calcula a posi√ß√£o inicial para centralizar a grade
        total_width = 3 * hole_width + 2 * horizontal_padding
        total_height = 3 * hole_height + 2 * vertical_padding
        start_x = (width - total_width) // 2
        start_y = (height - total_height) // 2

        # Coordenadas dos buracos (3x3)
        coordinates = []
        for row in range(3):
            for col in range(3):
                x0 = start_x + col * (hole_width + horizontal_padding)
                y0 = start_y + row * (hole_height + vertical_padding)
                x1 = x0 + hole_width
                y1 = y0 + hole_height
                coordinates.append((x0, y0, x1, y1))

        # Verifique quais figurinhas o usu√°rio possui na p√°gina atual
        cursor.execute('''
            SELECT stickers.id, stickers.image_path 
            FROM inventariofig 
            JOIN stickers ON inventariofig.sticker_id = stickers.id 
            WHERE inventariofig.user_id = %s AND stickers.page = %s
        ''', (user_id, page))
        stickers = cursor.fetchall()

        # Dicion√°rio de figurinhas do usu√°rio
        user_stickers = {sticker[0]: sticker[1] for sticker in stickers}

        # Preencha os buracos com as figurinhas
        for idx, coord in enumerate(coordinates):
            sticker_id = (page - 1) * 9 + idx + 1
            if sticker_id in user_stickers:
                # Carregar a figurinha correspondente do cache ou baixar se n√£o estiver no cache
                bordered_sticker = get_cached_sticker(user_stickers[sticker_id], hole_width, hole_height)
                
                # Colar a figurinha com borda na posi√ß√£o correta
                img.paste(bordered_sticker, (coord[0], coord[1]))
            else:
                # Preencher com buraco preto se a figurinha n√£o existir
                draw.rectangle(coord, fill='black')

        # Adicionar texto "P√°gina x/5" no rodap√©
        font = ImageFont.load_default()
        text = f"P√°gina {page}/5"
        text_bbox = draw.textbbox((0, 0), text, font=font)
        text_width = text_bbox[2] - text_bbox[0]
        text_x = (width - text_width) // 2
        text_y = height - 30  # 30 pixels acima do rodap√©
        draw.text((text_x, text_y), text, fill="black", font=font)

        # Salve a imagem
        img.save(ALBUM_PATH)
        cursor.close()
        conn.close()
        return True
    
    except Exception as e:
        print(f"Erro ao criar o √°lbum: {e}")
        return False
def get_user_stickers(user_id, page, stickers_per_page=9):
    conn, cursor = conectar_banco_dados()
    offset = (page - 1) * stickers_per_page
    cursor.execute('''
        SELECT stickers.id, stickers.image_path
        FROM inventariofig
        JOIN stickers ON inventariofig.sticker_id = stickers.id
        WHERE inventariofig.user_id = %s
        LIMIT %s OFFSET %s
    ''', (user_id, stickers_per_page, offset))
    stickers = cursor.fetchall()
    cursor.close()
    conn.close()
    return stickers

def get_total_pages(user_id, stickers_per_page=9):
    conn, cursor = conectar_banco_dados()
    cursor.execute('''
        SELECT COUNT(*)
        FROM inventariofig
        WHERE user_id = %s
    ''', (user_id,))
    total_stickers = cursor.fetchone()[0]
    cursor.close()
    conn.close()
    return (total_stickers + stickers_per_page - 1) // stickers_per_page

def get_album_markup(page, total_pages):
    markup = InlineKeyboardMarkup()
    if page > 1:
        markup.add(InlineKeyboardButton('Anterior', callback_data=f'prev_{page - 1}'))
    if page < total_pages:
        markup.add(InlineKeyboardButton('Pr√≥ximo', callback_data=f'next_{page + 1}'))
    return markup

def get_user_stickers(user_id, page, stickers_per_page=9):
    conn, cursor = conectar_banco_dados()
    offset = (page - 1) * stickers_per_page
    cursor.execute('''
        SELECT stickers.id, stickers.name, stickers.image_path, SUM(inventariofig.quantity)
        FROM inventariofig
        JOIN stickers ON inventariofig.sticker_id = stickers.id
        WHERE inventariofig.user_id = %s
        GROUP BY stickers.id
        LIMIT %s OFFSET %s
    ''', (user_id, stickers_per_page, offset))
    stickers = cursor.fetchall()
    cursor.close()
    conn.close()
    return stickers

def get_total_pages(user_id, stickers_per_page=9):
    conn, cursor = conectar_banco_dados()
    cursor.execute('''
        SELECT COUNT(DISTINCT sticker_id)
        FROM inventariofig
        WHERE user_id = %s
    ''', (user_id,))
    total_stickers = cursor.fetchone()[0]
    cursor.close()
    conn.close()
    return (total_stickers + stickers_per_page - 1) // stickers_per_page

def get_total_stickers(user_id):
    conn, cursor = conectar_banco_dados()
    cursor.execute('''
        SELECT COUNT(DISTINCT sticker_id)
        FROM inventariofig
        WHERE user_id = %s
    ''', (user_id,))
    total_stickers = cursor.fetchone()[0]
    cursor.close()
    conn.close()
    return total_stickers

def get_album_markup(page, total_pages):
    markup = InlineKeyboardMarkup()
    if page > 1:
        markup.add(InlineKeyboardButton('Anterior', callback_data=f'prev_{page - 1}'))
    if page < total_pages:
        markup.add(InlineKeyboardButton('Pr√≥ximo', callback_data=f'next_{page + 1}'))
    return markup

@bot.message_handler(commands=['alb'])
def send_album_list(message):
    user_id = message.from_user.id
    page = 1
    stickers = get_user_stickers(user_id, page)
    total_pages = get_total_pages(user_id)
    total_stickers = get_total_stickers(user_id)

    if not stickers:
        bot.reply_to(message, "Voc√™ n√£o possui figurinhas.")
        return

    user_name = message.from_user.first_name
    album_text = '\n'.join([f"luv{sticker[0]} - {sticker[1]}" + (f" (x{sticker[3]})" if sticker[3] > 1 else "") for sticker in stickers])
    markup = get_album_markup(page, total_pages)
    bot.send_message(message.chat.id, f"√Ålbum de figurinhas de {user_name}:\n\n{total_stickers}/40\n\n{album_text}", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data.startswith('prev_') or call.data.startswith('next_'))
def callback_page(call):
    user_id = call.from_user.id
    page = int(call.data.split('_')[1])
    stickers = get_user_stickers(user_id, page)
    total_pages = get_total_pages(user_id)
    total_stickers = get_total_stickers(user_id)

    if not stickers:
        bot.answer_callback_query(call.id, "Nenhuma figurinha nesta p√°gina.")
        return

    user_name = call.from_user.first_name
    album_text = '\n'.join([f"luv{sticker[0]} - {sticker[1]}" + (f" (x{sticker[3]})" if sticker[3] > 1 else "") for sticker in stickers])
    markup = get_album_markup(page, total_pages)
    bot.edit_message_text(f"√Ålbum de figurinhas de {user_name}:\n\n{total_stickers}/40\n\n{album_text}", chat_id=call.message.chat.id, message_id=call.message.message_id, reply_markup=markup)
    bot.answer_callback_query(call.id)

@bot.callback_query_handler(func=lambda call: call.data.startswith('prev_') or call.data.startswith('next_'))
def callback_page(call):
    user_id = call.from_user.id
    page = int(call.data.split('_')[1])
    stickers = get_user_stickers(user_id, page)
    total_pages = get_total_pages(user_id)

    if not stickers:
        bot.answer_callback_query(call.id, "Nenhuma figurinha nesta p√°gina.")
        return

    album_text = '\n'.join([f"Figurinha {sticker[0]}" for sticker in stickers])
    markup = get_album_markup(page, total_pages)
    bot.edit_message_text(f"√Ålbum (P√°gina {page}/{total_pages}):\n\n{album_text}", chat_id=call.message.chat.id, message_id=call.message.message_id, reply_markup=markup)
    bot.answer_callback_query(call.id)
def get_sticker_by_id(sticker_id):
    conn, cursor = conectar_banco_dados()
    cursor.execute('''
        SELECT id, name, image_path 
        FROM stickers 
        WHERE id = %s
    ''', (sticker_id,))
    sticker = cursor.fetchone()
    cursor.close()
    conn.close()
    return sticker

@bot.message_handler(commands=['fig'])
def send_sticker(message):
    try:
        args = message.text.split()
        if len(args) != 2:
            bot.reply_to(message, "Uso: /fig <id>")
            return
        
        sticker_id = int(args[1].replace('luv', ''))
        sticker = get_sticker_by_id(sticker_id)

        if not sticker:
            bot.reply_to(message, "Figurinha n√£o encontrada.")
            return

        sticker_id, name, image_path = sticker
        response = requests.get(image_path)
        sticker_image = Image.open(BytesIO(response.content))

        # Adicionar borda √† figurinha
        bordered_sticker = ImageOps.expand(sticker_image, border=2, fill='black')
        
        # Salvar a imagem final temporariamente
        result_image_path = 'sticker.png'
        bordered_sticker.save(result_image_path)

        caption = f"ID: luv{sticker_id}\nNome: {name}"

        # Enviar a imagem da figurinha
        with open(result_image_path, 'rb') as photo:
            bot.send_photo(message.chat.id, photo, caption=caption)

    except Exception as e:
        bot.reply_to(message, f"Houve um erro ao buscar a figurinha: {e}")

@bot.message_handler(commands=['trocafig'])
def trade_stickers(message):
    try:
        if not message.reply_to_message:
            bot.reply_to(message, "Voc√™ precisa responder a mensagem do usu√°rio com quem deseja trocar figurinhas.")
            return

        user_id = message.from_user.id
        target_user_id = message.reply_to_message.from_user.id

        args = message.text.split()
        if len(args) != 3:
            bot.reply_to(message, "Uso: /trocafig <meu_idfig> <idfig_alvo>")
            return

        my_sticker_id = int(args[1].replace('luv', ''))
        target_sticker_id = int(args[2].replace('luv', ''))

        conn, cursor = conectar_banco_dados()

        # Verificar se ambos os usu√°rios possuem as figurinhas especificadas
        cursor.execute('''
            SELECT quantity FROM inventariofig 
            WHERE user_id = %s AND sticker_id = %s
        ''', (user_id, my_sticker_id))
        my_sticker = cursor.fetchone()

        cursor.execute('''
            SELECT quantity FROM inventariofig 
            WHERE user_id = %s AND sticker_id = %s
        ''', (target_user_id, target_sticker_id))
        target_sticker = cursor.fetchone()

        if not my_sticker or not target_sticker:
            bot.reply_to(message, "Um dos usu√°rios n√£o possui a figurinha especificada.")
            cursor.close()
            conn.close()
            return

        # Enviar solicita√ß√£o de troca ao usu√°rio respondido
        markup = InlineKeyboardMarkup()
        markup.add(InlineKeyboardButton('Aceitar', callback_data=f'accept_{user_id}_{my_sticker_id}_{target_sticker_id}_{message.chat.id}'))
        markup.add(InlineKeyboardButton('Recusar', callback_data=f'reject_{message.chat.id}'))

        bot.send_message(
            message.chat.id,
            f"{message.reply_to_message.from_user.first_name}, voc√™ tem {target_sticker[0]} figurinha(s) do ID luv{target_sticker_id}. "
            f"Deseja trocar com {message.from_user.first_name} "
            f"pela figurinha ID luv{my_sticker_id}?",
            reply_markup=markup,
            reply_to_message_id=message.reply_to_message.message_id
        )

    except Exception as e:
        bot.reply_to(message, f"Houve um erro ao realizar a troca: {e}")

@bot.callback_query_handler(func=lambda call: call.data.startswith('accept_') or call.data.startswith('reject_'))
def handle_trade_response(call):
    try:
        if call.data.startswith('reject_'):
            chat_id = int(call.data.split('_')[1])
            bot.answer_callback_query(call.id, "Troca recusada.")
            bot.edit_message_text("Troca recusada.", chat_id=chat_id, message_id=call.message.message_id)
            return

        data = call.data.split('_')
        user_id = int(data[1])
        my_sticker_id = int(data[2])
        target_sticker_id = int(data[3])
        chat_id = int(data[4])
        target_user_id = call.from_user.id

        conn, cursor = conectar_banco_dados()

        # Verificar novamente se ambos os usu√°rios possuem as figurinhas especificadas
        cursor.execute('''
            SELECT quantity FROM inventariofig 
            WHERE user_id = %s AND sticker_id = %s
        ''', (user_id, my_sticker_id))
        my_sticker = cursor.fetchone()

        cursor.execute('''
            SELECT quantity FROM inventariofig 
            WHERE user_id = %s AND sticker_id = %s
        ''', (target_user_id, target_sticker_id))
        target_sticker = cursor.fetchone()

        if not my_sticker or not target_sticker:
            bot.answer_callback_query(call.id, "Um dos usu√°rios n√£o possui mais a figurinha especificada.")
            cursor.close()
            conn.close()
            return

        # Realizar a troca de figurinhas
        cursor.execute('''
            INSERT INTO inventariofig (user_id, sticker_id, quantity)
            VALUES (%s, %s, 1)
            ON DUPLICATE KEY UPDATE quantity = quantity + 1
        ''', (target_user_id, my_sticker_id))

        cursor.execute('''
            INSERT INTO inventariofig (user_id, sticker_id, quantity)
            VALUES (%s, %s, 1)
            ON DUPLICATE KEY UPDATE quantity = quantity + 1
        ''', (user_id, target_sticker_id))

        # Atualizar a quantidade das figurinhas trocadas
        cursor.execute('''
            UPDATE inventariofig SET quantity = quantity - 1 
            WHERE user_id = %s AND sticker_id = %s
        ''', (user_id, my_sticker_id))

        cursor.execute('''
            UPDATE inventariofig SET quantity = quantity - 1 
            WHERE user_id = %s AND sticker_id = %s
        ''', (target_user_id, target_sticker_id))

        # Remover a figurinha do invent√°rio se a quantidade for zero
        cursor.execute('''
            DELETE FROM inventariofig 
            WHERE user_id = %s AND sticker_id = %s AND quantity = 0
        ''', (user_id, my_sticker_id))

        cursor.execute('''
            DELETE FROM inventariofig 
            WHERE user_id = %s AND sticker_id = %s AND quantity = 0
        ''', (target_user_id, target_sticker_id))

        conn.commit()
        cursor.close()
        conn.close()

        bot.edit_message_text("Troca realizada com sucesso!", chat_id=chat_id, message_id=call.message.message_id)
        bot.send_message(chat_id, f"{call.from_user.first_name} aceitou a troca. {call.from_user.first_name} trocou luv{my_sticker_id} por luv{target_sticker_id} com {call.from_user.first_name}.")

    except Exception as e:
        bot.answer_callback_query(call.id, f"Houve um erro ao realizar a troca: {e}")
def get_all_stickers():
    conn, cursor = conectar_banco_dados()
    cursor.execute('SELECT id, name FROM stickers')
    all_stickers = cursor.fetchall()
    cursor.close()
    conn.close()
    return all_stickers

def get_user_stickers(user_id):
    conn, cursor = conectar_banco_dados()
    cursor.execute('SELECT sticker_id FROM inventariofig WHERE user_id = %s', (user_id,))
    user_stickers = {row[0] for row in cursor.fetchall()}
    cursor.close()
    conn.close()
    return user_stickers

def get_missing_stickers(user_id, page, stickers_per_page=9):
    all_stickers = get_all_stickers()
    user_stickers = get_user_stickers(user_id)
    missing_stickers = [sticker for sticker in all_stickers if sticker[0] not in user_stickers]
    
    start = (page - 1) * stickers_per_page
    end = start + stickers_per_page
    return missing_stickers[start:end], len(missing_stickers)

def get_missing_album_markup(page, total_pages):
    markup = InlineKeyboardMarkup()
    if page > 1:
        markup.add(InlineKeyboardButton('Anterior', callback_data=f'missing_prev_{page - 1}'))
    if page < total_pages:
        markup.add(InlineKeyboardButton('Pr√≥ximo', callback_data=f'missing_next_{page + 1}'))
    return markup

@bot.message_handler(commands=['albf'])
def send_missing_album_list(message):
    user_id = message.from_user.id
    page = 1
    stickers_per_page = 9
    missing_stickers, total_missing = get_missing_stickers(user_id, page, stickers_per_page)
    total_pages = (total_missing + stickers_per_page - 1) // stickers_per_page

    if not missing_stickers:
        bot.reply_to(message, "Voc√™ j√° possui todas as figurinhas.")
        return

    user_name = message.from_user.first_name
    album_text = '\n'.join([f"luv{sticker[0]} - {sticker[1]}" for sticker in missing_stickers])
    markup = get_missing_album_markup(page, total_pages)
    bot.send_message(message.chat.id, f"√Ålbum de figurinhas faltantes de {user_name}:\n\n{total_missing}/40\n\n{album_text}", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data.startswith('missing_prev_') or call.data.startswith('missing_next_'))
def callback_page_missing(call):
    user_id = call.from_user.id
    page = int(call.data.split('_')[2])
    stickers_per_page = 9
    missing_stickers, total_missing = get_missing_stickers(user_id, page, stickers_per_page)
    total_pages = (total_missing + stickers_per_page - 1) // stickers_per_page

    if not missing_stickers:
        bot.answer_callback_query(call.id, "Nenhuma figurinha faltante nesta p√°gina.")
        return

    user_name = call.from_user.first_name
    album_text = '\n'.join([f"luv{sticker[0]} - {sticker[1]}" for sticker in missing_stickers])
    markup = get_missing_album_markup(page, total_pages)
    bot.edit_message_text(f"√Ålbum de figurinhas faltantes de {user_name}:\n\n{total_missing}/40\n\n{album_text}", chat_id=call.message.chat.id, message_id=call.message.message_id, reply_markup=markup)
    bot.answer_callback_query(call.id)

# Fun√ß√£o para lidar com o comando /gnome
@bot.message_handler(commands=['gnome'])
def gnome(message):
    chat_id = message.chat.id
    user_id = message.from_user.id
    with concurrent.futures.ThreadPoolExecutor() as executor:
        future = executor.submit(processar_comando_gnome, chat_id, user_id, message)
        future.result()

def processar_comando_gnome(chat_id, user_id, message):
    conn, cursor = conectar_banco_dados()
    try:
        nome = message.text.split('/gnome', 1)[1].strip()

        if nome.startswith("e "):
            nome_evento = nome[1:].strip()
            sql_eventos_exatas = """
                SELECT
                    e.id_personagem,
                    e.nome,
                    e.subcategoria,
                    e.categoria,
                    e.evento,
                    e.imagem,
                    e.emoji
                FROM evento e
                WHERE e.nome = %s
                LIMIT 50
            """
            sql_eventos_parciais = """
                SELECT
                    e.id_personagem,
                    e.nome,
                    e.subcategoria,
                    e.categoria,
                    e.evento,
                    e.imagem,
                    e.emoji
                FROM evento e
                WHERE e.nome LIKE %s AND e.nome <> %s
                LIMIT 50
            """
            values_eventos_exatas = (nome_evento,)
            values_eventos_parciais = (f"%{nome_evento}%", nome_evento)

            cursor.execute(sql_eventos_exatas, values_eventos_exatas)
            resultados_exatos = cursor.fetchall()

            cursor.execute(sql_eventos_parciais, values_eventos_parciais)
            resultados_parciais = cursor.fetchall()

            resultados_personagens = resultados_exatos + resultados_parciais
        else:
            sql_personagens_exatas = """
                SELECT
                    p.id_personagem,
                    p.nome,
                    p.subcategoria,
                    p.categoria,
                    i.quantidade AS quantidade_usuario,
                    p.imagem,
                    p.emoji
                FROM personagens p
                LEFT JOIN inventario i ON p.id_personagem = i.id_personagem AND i.id_usuario = %s
                WHERE p.nome = %s
                LIMIT 50
            """
            sql_personagens_parciais = """
                SELECT
                    p.id_personagem,
                    p.nome,
                    p.subcategoria,
                    p.categoria,
                    i.quantidade AS quantidade_usuario,
                    p.imagem,
                    p.emoji
                FROM personagens p
                LEFT JOIN inventario i ON p.id_personagem = i.id_personagem AND i.id_usuario = %s
                WHERE p.nome LIKE %s AND p.nome <> %s
                LIMIT 50
            """
            values_personagens_exatas = (user_id, nome)
            values_personagens_parciais = (user_id, f"%{nome}%", nome)

            cursor.execute(sql_personagens_exatas, values_personagens_exatas)
            resultados_exatos = cursor.fetchall()

            cursor.execute(sql_personagens_parciais, values_personagens_parciais)
            resultados_parciais = cursor.fetchall()

            resultados_personagens = resultados_exatos + resultados_parciais

        if len(resultados_personagens) == 0:
            bot.send_message(chat_id, "Nenhum personagem encontrado.", reply_to_message_id=message.message_id)
            return

        mensagens = []
        for resultado_personagem in resultados_personagens:
            if len(resultado_personagem) == 7:  # Caso para eventos
                id_personagem, nome_personagem, subcategoria, categoria, evento, imagem_url, emoji = resultado_personagem
                quantidade_usuario = None  # Definido como None, pois eventos n√£o t√™m quantidade
            else:
                id_personagem, nome_personagem, subcategoria, categoria, quantidade_usuario, imagem_url, emoji = resultado_personagem

            mensagem = f"üíå | Personagem: \n\n<code>{id_personagem}</code> ‚Ä¢ {nome_personagem}\nde {subcategoria}"
            if quantidade_usuario is None:
                mensagem += f"\n\nüåß | Tempo fechado..."
            elif quantidade_usuario > 0:
                mensagem += f"\n\n‚òÄ | {quantidade_usuario}‚§´"
            else:
                mensagem += f"\n\nüåß | Tempo fechado..."

            gif_url = obter_gif_url(id_personagem, user_id)
            if gif_url:
                mensagens.append((gif_url, mensagem))
            elif imagem_url:
                mensagens.append((imagem_url, mensagem))
            else:
                mensagens.append((None, mensagem))

        user_messages[f"{chat_id}_{nome}"] = mensagens

        if len(mensagens) == 1:
            media_url, mensagem = mensagens[0]
            if media_url and media_url.lower().endswith(".gif"):
                bot.send_animation(chat_id, media_url, caption=mensagem, parse_mode="HTML", reply_to_message_id=message.message_id)
            elif media_url and media_url.lower().endswith(".mp4"):
                bot.send_video(chat_id, media_url, caption=mensagem, parse_mode="HTML", reply_to_message_id=message.message_id)
            elif media_url and media_url.lower().endswith((".jpeg", ".jpg", ".png")):
                bot.send_photo(chat_id, media_url, caption=mensagem, parse_mode="HTML", reply_to_message_id=message.message_id)
            else:
                bot.send_message(chat_id, mensagem, parse_mode="HTML", reply_to_message_id=message.message_id)
        else:
            enviar_mensagem_com_botoes(chat_id, mensagens, 0, reply_to_message_id=message.message_id, nome_pesquisa=nome)

    except Exception as e:
        import traceback
        traceback.print_exc()
    finally:
        cursor.close()
        conn.close()

def enviar_mensagem_com_botoes(chat_id, mensagens, current_index, reply_to_message_id=None, nome_pesquisa=''):
    total_count = len(mensagens)

    if total_count == 0:
        bot.send_message(chat_id, "Nenhum personagem encontrado.", reply_to_message_id=reply_to_message_id)
        return

    media_url, mensagem = mensagens[current_index]
    markup = criar_marcacao_navegacao(current_index, total_count, nome_pesquisa)

    if media_url and media_url.lower().endswith(".gif"):
        bot.send_animation(chat_id, media_url, caption=mensagem, reply_markup=markup, parse_mode="HTML", reply_to_message_id=reply_to_message_id)
    elif media_url and media_url.lower().endswith(".mp4"):
        bot.send_video(chat_id, media_url, caption=mensagem, reply_markup=markup, parse_mode="HTML", reply_to_message_id=reply_to_message_id)
    elif media_url and media_url.lower().endswith((".jpeg", ".jpg", ".png")):
        bot.send_photo(chat_id, media_url, caption=mensagem, reply_markup=markup, parse_mode="HTML", reply_to_message_id=reply_to_message_id)
    else:
        bot.send_message(chat_id, mensagem, reply_markup=markup, parse_mode="HTML", reply_to_message_id=reply_to_message_id)

def criar_marcacao_navegacao(current_index, total_count, nome_pesquisa):
    markup = types.InlineKeyboardMarkup()
    prev_button_text = "‚¨Ö"
    next_button_text = "‚û°Ô∏è"
    prev_button_callback = f"navigate_{current_index}_prev_{nome_pesquisa}"
    next_button_callback = f"navigate_{current_index}_next_{nome_pesquisa}"

    buttons = [
        types.InlineKeyboardButton(text=prev_button_text, callback_data=prev_button_callback),
        types.InlineKeyboardButton(text=next_button_text, callback_data=next_button_callback)
    ]
    markup.add(*buttons)
    return markup

@bot.callback_query_handler(func=lambda call: call.data.startswith('navigate'))
def navigate_messages(call):
    try:
        chat_id = call.message.chat.id
        data_parts = call.data.split('_')

        if len(data_parts) == 4:
            direction = data_parts[2]
            current_index = int(data_parts[1])
            nome_pesquisa = data_parts[3]
        else:
            raise ValueError("Callback_data com n√∫mero incorreto de partes ou formato inv√°lido.")

        mensagens = user_messages.get(f"{chat_id}_{nome_pesquisa}", [])
        total_count = len(mensagens)

        if direction == 'next':
            current_index = (current_index + 1) % total_count
        elif direction == 'prev':
            current_index = (current_index - 1 + total_count) % total_count

        media_url, mensagem = mensagens[current_index]
        markup = criar_marcacao_navegacao(current_index, total_count, nome_pesquisa)

        if media_url and media_url.lower().endswith(".gif"):
            bot.edit_message_media(chat_id=chat_id, message_id=call.message.message_id, media=types.InputMediaAnimation(media_url, caption=mensagem, parse_mode="HTML"), reply_markup=markup)
        elif media_url and media_url.lower().endswith(".mp4"):
            bot.edit_message_media(chat_id=chat_id, message_id=call.message.message_id, media=types.InputMediaVideo(media_url, caption=mensagem), reply_markup=markup)
        elif media_url and media_url.lower().endswith((".jpeg", ".jpg", ".png")):
            bot.edit_message_media(chat_id=chat_id, message_id=call.message.message_id, media=types.InputMediaPhoto(media_url, caption=mensagem, parse_mode="HTML"), reply_markup=markup)
        else:
            bot.edit_message_text(chat_id=chat_id, message_id=call.message.message_id, text=mensagem, reply_markup=markup, parse_mode="HTML")

    except Exception as e:
        print("Erro ao processar callback dos bot√µes de navega√ß√£o:", str(e))

# Fun√ß√£o para lidar com o comando /gnomes
@bot.message_handler(commands=['gnomes'])
def gnomes(message):
    chat_id = message.chat.id
    user_id = message.from_user.id
    with concurrent.futures.ThreadPoolExecutor() as executor:
        future = executor.submit(processar_comando_gnomes, chat_id, user_id, message)
        future.result()

def processar_comando_gnomes(chat_id, user_id, message):
    conn, cursor = conectar_banco_dados()
    try:
        nome = message.text.split('/gnomes', 1)[1].strip()

        if nome.startswith("e "):
            nome_evento = nome[1:].strip()
            sql_eventos_exatas = """
                SELECT
                    e.id_personagem,
                    e.nome,
                    e.subcategoria,
                    e.categoria,
                    NULL AS quantidade_usuario,
                    e.imagem
                FROM evento e
                WHERE e.nome = %s
            """
            sql_eventos_parciais = """
                SELECT
                    e.id_personagem,
                    e.nome,
                    e.subcategoria,
                    e.categoria,
                    NULL AS quantidade_usuario,
                    e.imagem
                FROM evento e
                WHERE e.nome LIKE %s AND e.nome <> %s
            """
            values_eventos_exatas = (nome_evento,)
            values_eventos_parciais = (f"%{nome_evento}%", nome_evento)

            cursor.execute(sql_eventos_exatas, values_eventos_exatas)
            resultados_exatos = cursor.fetchall()

            cursor.execute(sql_eventos_parciais, values_eventos_parciais)
            resultados_parciais = cursor.fetchall()

            resultados_personagens = resultados_exatos + resultados_parciais
        else:
            sql_personagens_exatas = """
                SELECT
                    p.id_personagem,
                    p.nome,
                    p.subcategoria,
                    p.categoria,
                    i.quantidade AS quantidade_usuario,
                    p.imagem,
                    p.emoji
                FROM personagens p
                LEFT JOIN inventario i ON p.id_personagem = i.id_personagem AND i.id_usuario = %s
                WHERE p.nome = %s
            """
            sql_personagens_parciais = """
                SELECT
                    p.id_personagem,
                    p.nome,
                    p.subcategoria,
                    p.categoria,
                    i.quantidade AS quantidade_usuario,
                    p.imagem,
                    p.emoji
                FROM personagens p
                LEFT JOIN inventario i ON p.id_personagem = i.id_personagem AND i.id_usuario = %s
                WHERE p.nome LIKE %s AND p.nome <> %s
            """
            values_personagens_exatas = (user_id, nome)
            values_personagens_parciais = (user_id, f"%{nome}%", nome)

            cursor.execute(sql_personagens_exatas, values_personagens_exatas)
            resultados_exatos = cursor.fetchall()

            cursor.execute(sql_personagens_parciais, values_personagens_parciais)
            resultados_parciais = cursor.fetchall()

            resultados_personagens = resultados_exatos + resultados_parciais

        if len(resultados_personagens) == 0:
            bot.send_message(chat_id, "Nenhum personagem encontrado.", reply_to_message_id=message.message_id)
            return

        total_paginas = (len(resultados_personagens) + 14) // 15
        user_messages[f"{chat_id}_{nome}"] = {
            'mensagens': resultados_personagens,
            'total_paginas': total_paginas
        }

        enviar_pagina_gnomes(chat_id, resultados_personagens, 1, total_paginas, nome)

    except Exception as e:
        import traceback
        traceback.print_exc()
    finally:
        cursor.close()
        conn.close()

def enviar_pagina_gnomes(chat_id, mensagens, pagina_atual, total_paginas, nome_pesquisa, reply_to_message_id=None):
    total_count = len(mensagens)
    offset = (pagina_atual - 1) * 15
    mensagens_pagina = mensagens[offset:offset + 15]

    resposta = f"üê† Peixes de nome '{nome_pesquisa}', p√°gina {pagina_atual}/{total_paginas}:\n\n"
    for msg in mensagens_pagina:
        id_personagem, nome, subcategoria, categoria, quantidade_usuario, imagem_url, emoji = msg
        resposta += f"{emoji} {id_personagem} ‚Ä¢ {nome}\nde {subcategoria}\n"

    markup = criar_marcacao_navegacao_gnomes(pagina_atual, total_paginas, nome_pesquisa)

    if reply_to_message_id:
        bot.edit_message_text(resposta, chat_id=chat_id, message_id=reply_to_message_id, reply_markup=markup, parse_mode="HTML")
    else:
        bot.send_message(chat_id, resposta, reply_markup=markup, parse_mode="HTML")

def criar_marcacao_navegacao_gnomes(pagina_atual, total_paginas, nome_pesquisa):
    markup = types.InlineKeyboardMarkup()
    prev_button_text = "‚¨Ö"
    next_button_text = "‚û°Ô∏è"
    prev_button_callback = f"gnomes_{pagina_atual}_prev_{nome_pesquisa}"
    next_button_callback = f"gnomes_{pagina_atual}_next_{nome_pesquisa}"

    buttons = []
    if pagina_atual > 1:
        buttons.append(types.InlineKeyboardButton(text=prev_button_text, callback_data=prev_button_callback))
    if pagina_atual < total_paginas:
        buttons.append(types.InlineKeyboardButton(text=next_button_text, callback_data=next_button_callback))

    markup.add(*buttons)
    return markup

@bot.callback_query_handler(func=lambda call: call.data.startswith('gnomes'))
def navigate_gnomes(call):
    try:
        chat_id = call.message.chat.id
        data_parts = call.data.split('_')

        if len(data_parts) == 4:
            direction = data_parts[2]
            pagina_atual = int(data_parts[1])
            nome_pesquisa = data_parts[3]
        else:
            raise ValueError("Callback_data com n√∫mero incorreto de partes ou formato inv√°lido.")

        mensagens_data = user_messages.get(f"{chat_id}_{nome_pesquisa}", {})
        mensagens = mensagens_data.get('mensagens', [])
        total_paginas = mensagens_data.get('total_paginas', 1)

        if direction == 'next':
            pagina_atual = (pagina_atual % total_paginas) + 1
        elif direction == 'prev':
            pagina_atual = (pagina_atual - 2 + total_paginas) % total_paginas + 1

        enviar_pagina_gnomes(chat_id, mensagens, pagina_atual, total_paginas, nome_pesquisa, reply_to_message_id=call.message.message_id)

    except Exception as e:
        print("Erro ao processar callback dos bot√µes de navega√ß√£o:", str(e))


bot.polling()
